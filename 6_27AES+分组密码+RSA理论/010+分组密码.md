# 010 分组密码

密码算法可以分为分组密码和流密码两种

* **分组密码（block cipher）**是每次只能处理特定长度的一块数据的一类密码算法，这里的“一块”就称为分组（block）。一个分组的比特数就称为分组长度（block lenght）。

    例如 DES和3DES的分组长度都是64比特。AES的分组长度为128比特。

* **流密码（stream cipher）**是对数据流进行连续处理的一类密码算法。流密码中一般以1比特、8比特、或32比特等为单位进行加密和解密。

分组密码处理完一个分组就结束了，因此不需要通过内部状态来记录加密的进度；相对地，流密码是对一串数据进行连续处理，因此需要保持内部状态。

## 模式

分组密码算法只能加密固定长度的分组，但是我们需要加密的明文长度可能会超过分组密码的分组长度，这时就需要对分组密码算法进行迭代，以便将一段很长的明文全部加密。而迭代的方法就称为分组密码的模式（mode）。

* ECB模式：Electronic CodeBook mode（电子密码模式）
* CBC模式：Cipher Block Chaining mode（密码分组链接模式）
* CFB模式：Cipher FeedBack mode（密文反馈模式）
* OFB模式：Output FeedBack mode（输出反馈模式）
* CTR模式：CounTeR mode（计数器模式）

## ECB模式

在ECB模式中，将明文分组加密之后的结果直接成为密文分组。当最后一个明文分组的内容小于分组长度时，需要用一些特定的数据进行填充（padding）。

**明文分组**：是指分组密码算法中作为加密对象的明文。
**密文分组**：是指使用分组密码算法中将明文分组加密之后所生成的密文。

![](http://olgjbx93m.bkt.clouddn.com/WX20180116-192036.png)

使用 ECB 模式加密时，相同的明文分组会转换为相同的密文分组，也就是说，我们可以将其理解为是一个巨大的“明文分组->密文分组”的对应表，因此 ECB 模式也称为 **电子密码本模式**。

### ECB模式的特点

ECB模式是所有模式中最简单的一种。ECB的明文分组与密文分组是一一对应的关系，因此，如果明文中存在多个相同的明文分组，则这些明文分组最终都会将被转换为相同的密文分组。这样一来，只要观察一下密文，就可以知道明文中存在怎样的重复组合，并可以以此为线索来破译密码，因此ECB模式是存在风险的。

### 对ECB模式的攻击

假如存在主动攻击者Mallory，它能够改变密文分组的顺序。当接收者对密文进行解密时，由于密文分组的顺序被改变了，因此相应的明文分组的顺序也会改变。也就是说，攻击者Mallory无需破译密码就能够操纵明文。

列举一个银行转账的简单例子，假设某银行转账数据由以下3个分组构成。

```
分组1 = 付款人的银行账号
分组2 = 收款人的银行账号
分组3 = 转转金额
```

我们可以制作一个“从 A 账号 向 B账号转账1000元”的数据，用16进制数据表示如下：

```
明文分组1 = 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 （付款人：A）

明文分组2 = 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30  （收款人： B）

明文分组3 = 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40  （转账金额： 1000）
```
经过 ECB模式进行加密，

```
密文分组1 = 1A 2C 1A 2C 1A 2C 1A 2C 1A 2C 1A 2C 1A 2C 1A 2C （付款人：*）

密文分组2 = 2D 3F 2D 3F 2D 3F 2D 3F 2D 3F 2D 3F 2D 3F 2D 3F （收款人： *）

密文分组3 = 4D 5E 4D 5E 4D 5E 4D 5E 4D 5E 4D 5E 4D 5E 4D 5E （转账金额： **）
```

如果攻击者 Mallory 将密文分组1 和 2 内容对调，

```
密文分组1 = 2D 3F 2D 3F 2D 3F 2D 3F 2D 3F 2D 3F 2D 3F 2D 3F （付款人： *）

密文分组2 = 1A 2C 1A 2C 1A 2C 1A 2C 1A 2C 1A 2C 1A 2C 1A 2C （收款人：*）

密文分组3 = 4D 5E 4D 5E 4D 5E 4D 5E 4D 5E 4D 5E 4D 5E 4D 5E （转账金额： **）
```
那请求内容从A向B转账1000，变成了B向A转账1000。我们可以看出ECB模式的缺点是可以在不破译密文的情况下操纵明文。

## CBC模式

CBC模式，全称Cipher Block Chaining模式，译为密文分组链接模式，即加密算法的输入是上一个密文分组和下一个明文分组的异或。因为是将上一个密文分组和下一个明文分组的内容混合加密，因此可以避免ECB模式的缺陷。当加密第一个明文分组时，由于不存在上一个密文分组，因此需要准备与分组等长的初始化向量IV，来代替上一个密文分组。

![](http://olgjbx93m.bkt.clouddn.com/WX20180116-201449.png)

**初始化向量**：当加密第一个明文分组时，由于不存在“前一个密文分组”，因此需要事先准备一个长度为一个分组的比特序列来代替“前一个密文分组”，这个比特序列称为初始化向量，通常缩写为IV。

```
func NewCBCEncrypter(b Block, iv []byte) BlockMode
```
当我们使用 CBC模式的时候，需要传入 iv（初始化向量）

### CBC模式的特点

* 明文分组在加密之前一定会与“前一个密文分组”进行XOR运算，因此即便明文分组1和2的值是相等的，密文分组1和2的值也不一定是相等的。这样ECB模式的缺陷在CBC模式中就不存在了。

* 在CBC模式中，无法单独对一个中间的明文分组进行加密。例如，如果要生成密文分组3，则至少需要凑齐明文分组1、2、3才行。

* 如果密文分组中有一些比特缺失了，即便只缺失了1比特，那么缺失比特的位置之后的密文分组也就全部无法解密了。

### 对CBC模式的攻击

假设主动攻击者Mallory的目的是通过修改密文来操纵解密后的明文。如果Mallory能够对初始化向量中任意比特进行反转，则解密后得到的明文分组中相应的比特也会被反转。

![](http://olgjbx93m.bkt.clouddn.com/WX20180116-202558.png)

## CFB模式

CFB模式，全称Cipher FeedBack模式，译为密文反馈模式，即上一个密文分组作为加密算法的输入，输出与明文异或作为下一个分组的密文。在CFB模式中，明文分组和密文分组之间只有一次异或。

![](http://olgjbx93m.bkt.clouddn.com/WX20180116-203020.png)

CFB模式与一次性密码本相似，都是通过将明文与随机比特序列进行异或运算来生成密文。但由于CFB模式中密码算法的输出是通过计算得到的，并非真正的随机数，因此不具备一次性密码本那样理论上不可破译的性质。CFB模式可以看做使用分组方式实现流密码的方式。

### 对CFB模式的攻击

对CFB模式可以实施 **重放攻击（replay attack）**

有一天 A 向 B 发送了一条消息，这条消息由4个密文分组组成，攻击者将后3个密文分组保存下来，第二天，A又向 B 发送内容不同的4个密文分组，攻击者将后3个密文分组进行替换。解密的时候就会发现第一个可以解密正确，第2个会出现错误，而第3个和第4个则变成攻击者替换的内容。

![](http://olgjbx93m.bkt.clouddn.com/WX20180116-204000.png)


## OFB模式

OFB模式，全称Output Feedback模式，译为输出反馈模式。OFB模式与CFB模式类似，只是加密算法的输入是上一次加密的输出。

OFB模式不是通过密码算法对明文直接进行加密的，而是通过将“**明文分组**”和“**密码算法的输出**”进行XOR来产生“密文分组”的。
 
OFB模式加密和处理解密逻辑相同，明文与密钥流异或生成密文，密文与密钥流异或生成明文。
　　
![](http://olgjbx93m.bkt.clouddn.com/WX20180116-204818.png)
　　
![](http://olgjbx93m.bkt.clouddn.com/WX20180116-204840.png)


## CTR模式

CTR模式，全称Counter模式，译为计数器模式。CTR模式中，每个分组对应一个逐次累加的计数器，并通过对计数器进行加密来生成密钥流。也即最终的密文分组是通过将计数器加密得到的比特序列，与明文分组进行异或运算得到的。

![](http://olgjbx93m.bkt.clouddn.com/WX20180116-205323.png)

### CTR模式的特点

* CTR模式的加密和解密使用了完全相同的结构，因此在程序实现上比较容易。这一特点和同为流密码的OFB模式是一样的。

* CTR模式中可以以任意顺序对分组进行加密和解密，因此在加密和解密时需要用到的“计数器”的值可以由nonce和分组序号直接计算出来。能够以任意顺序处理分组，就以为着能够实现并行计算。在支持并行计算的系统中，CTR模式的速度是非常快的。

### 错误与机密性

* 假设CTR模式的密文分组中有一个比特被反转了，则解密后明文分组中仅有与之对应的比特会被反转，这一错误不会放大，这一弱点和OFB模式是相同的。

* 在OFB模式中，如果对密钥流的一个分组进行加密后其结果碰巧和加密前是相同的，那么这一分组之后的密钥流就会变成同一值的不断反复。在CTR模式中就不存在这一问题。

## 分组密码模式比较

| 模式 | 优点 | 缺点 | 备注 |
| --- | --- | --- | --- |
| ECB模式 | 简单<br/> 快速<br/> 支持并行运算  | 明文中的重复排列反映在密文中<br/> 通过删除、替换密文分组可以对明文进行操作 <br/> 对包含某些比特错误的密文进行解密时对应的分组会出错 <br/> 不能抵御重放攻击 | 不应使用 |
| CBC模式 | 明文的重复排列不会反映在密文中<br/> 支持并行运算（仅解密）<br/> 能够解密任意密文分组 | 对包含某些错误比特的密文进行解密时，第一个分组的全部比特以及后一个分组的相应比特会出错<br> 加密不支持并行运算 |  CRYPRTREC推荐 《应用密码学》推荐|
| CFB模式 | 不需要填充<br/> 支持并行计算（仅解密）<br/> 能够解密任意密文分组 | 加密不支持并行计算<br/> 对包含某些错误比特的密文进行解密时，第一个分组的全部比特以及后一个分组的相应比特会出错<br/> 不能抵御重放攻击 |  CRYPRTREC推荐 |
| OFB模式 | 不需要填充<br/> 可事先进行加密、解密的准备 <br/> 加密、解密使用相同结构 <br/> 对包含某些错误比特的密文进行解密时，只有明文中相对应的比特会出错 | 不支持并行计算 <br/> 主动攻击者反转密文分组中的某些比特时，明文分组中相对应的比特也会被反转 | CRYPRTREC推荐 |
| CTR模式 | 不需要填充<br/> 可事先进行加密、解密的准备 <br/> 加密、解密使用相同结构 <br/> 对包含某些错误比特的密文进行解密时，只有明文中相对应的比特会出错 <br/> 支持并行计算（加密、解密） | 主动攻击者反转密文分组中的某些比特时，明文分组中相对应的比特也会被反转 | CRYPRTREC推荐 《应用密码学》推荐 |

